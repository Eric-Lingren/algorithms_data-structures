const _ = require('lodash')

// Create Node constructor for the Tree graph of nodes
// The nodes will be generated by the 'push' method we create
// on our BinarySearchTree, and that will take the values from
// our number array and turn them into nodes before placing them in 
// the BinarySearchTree
function Node(value){
    this.left = null
    this.right = null
    this.value = value
}

// Tree must have a root node which is the top of the tree table
function BinarySearchTree(){
    this.root = null
}

// method used to loop through our array of shuffled numbers, turn
// them into nodes, and place them on the tree appropriately
BinarySearchTree.prototype.push = function(val){
    const root = this.root
    if(!root){
        this.root = new Node(val)
    }

    let currentNode = root
    let newNode = new Node(val)

    while(currentNode){
        if(val < currentNode.value){
            if(!currentNode.left){
                currentNode.left = newNode
                break;
            } else {
                currentNode = currentNode.left
            }
        } else {
            if(!currentNode.right){
                currentNode.right = newNode
                break;
            } else {
                currentNode = currentNode.right
            }
        }
    }
}

// Data set we populate using the makeDatas function below
// change the i < <thisNumber> to change the size of your data set
// 2 million and below should work fine
const dataSet = []

const makeDatas = () => {
    for(let i = 0; i < 5000000; i++){
        dataSet.push(i)
    }
}

// making our dataset
makeDatas()
// shuffling our dataset so that it is not sorted
const shuffledData = _.shuffle(dataSet)

// Creates our BinarySearchTree, and uses the 'push' method we made
// to add the current number from our shuffled array as a Node on the Tree.
function treeSort(arr){
    const bst = new BinarySearchTree()
    for(let i = 0; i < arr.length; i++){
        bst.push(arr[i])
    }
    return bst
}

// Finalized Tree of nodes we can use binary search to look through
const tree = treeSort(shuffledData)


// Binary search algorithm that takes the finalized tree and the target
// number we want to find
// Iterations are not necessary, but is used to track how many times it has
// to run in comparison to the Linear search below
const binarySearch = (tree, target) => {
    let found = false
    let result = null
    let currentNode = tree.root
    let iterations = 0
    while(!found){
        iterations++
        if(target === currentNode.value){
            result = currentNode
            found = true
            break
        } else if(target < currentNode.value){
            if(currentNode.left){
                if(currentNode.left.value === target){
                    result = currentNode.left
                    found = true
                    break
                } else {
                    currentNode = currentNode.left
                }
            }
        } else if(target > currentNode.value){
            if(currentNode.right){
                if(currentNode.right.value === target){
                    found = true
                    result = currentNode.right
                    break
                } else {
                    currentNode = currentNode.right
                }
            }
        }
    }
    return {result, iterations}
}


// Linear search algorithm, must check each number at a time till it finds
// the target number
function linearSearch(arr, target){
    let iterations = 0
    for(let i = 0; i < arr.length; i++){
        iterations++
        if(arr[i] === target){
            return {result: arr[i], iterations}
        }
    }
}


console.time("Binary search")
const result = binarySearch(tree, 1230701)
console.timeEnd("Binary search")
console.log(result.iterations)

console.time("linear search")
const result2 = linearSearch(shuffledData, 1230701)
console.timeEnd("linear search")
console.log(result2.iterations)








